"""
Autonomous Monitoring Agent (DISC-140).

Continuously monitors Quoted's health and surfaces issues proactively.
The founder should wake up to a briefing, not a crisis.

Capabilities:
- Critical health checks (every 15 minutes)
- Business metrics monitoring (hourly)
- Daily summary email (8:15 AM UTC)
- Alert deduplication and throttling

Cost: $0 additional (uses existing infrastructure)
"""

from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from dataclasses import dataclass, field
from enum import Enum

from sqlalchemy import select, func, and_
from sqlalchemy.ext.asyncio import AsyncSession

from .logging import get_logger
from .health import check_all_health, HealthStatus
from .alerts import alert_service, AlertSeverity, AlertCategory
from ..config import settings

logger = get_logger("quoted.monitoring_agent")


class MonitoringStatus(Enum):
    """Overall monitoring status."""
    GREEN = "green"      # All systems healthy
    YELLOW = "yellow"    # Degraded but functional
    RED = "red"          # Critical issues


@dataclass
class HealthCheckResult:
    """Result of a health check."""
    name: str
    status: MonitoringStatus
    latency_ms: Optional[float] = None
    message: Optional[str] = None
    details: Optional[Dict[str, Any]] = None


@dataclass
class MonitoringAlert:
    """An alert generated by the monitoring agent."""
    alert_type: str
    severity: str  # 'critical', 'warning', 'info'
    message: str
    timestamp: datetime = field(default_factory=datetime.utcnow)
    details: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "type": self.alert_type,
            "severity": self.severity,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "details": self.details or {}
        }


# Alert deduplication cache (in-memory, cleared on restart)
_recent_alerts: Dict[str, datetime] = {}
ALERT_DEDUP_WINDOW = timedelta(hours=1)
CRITICAL_DEDUP_WINDOW = timedelta(minutes=15)


def _should_send_alert(alert_key: str, severity: str) -> bool:
    """Check if we should send an alert (deduplication)."""
    now = datetime.utcnow()

    if alert_key in _recent_alerts:
        last_sent = _recent_alerts[alert_key]
        window = CRITICAL_DEDUP_WINDOW if severity == "critical" else ALERT_DEDUP_WINDOW
        if now - last_sent < window:
            return False

    _recent_alerts[alert_key] = now
    return True


def _cleanup_dedup_cache():
    """Clean up old entries from dedup cache."""
    now = datetime.utcnow()
    cutoff = now - ALERT_DEDUP_WINDOW

    keys_to_remove = [
        key for key, timestamp in _recent_alerts.items()
        if timestamp < cutoff
    ]

    for key in keys_to_remove:
        del _recent_alerts[key]


class MonitoringAgentService:
    """
    Autonomous monitoring agent for Quoted.

    Runs on schedule to check system health and business metrics,
    alerting the founder proactively when issues are detected.
    """

    # Thresholds for health checks
    API_LATENCY_WARNING_MS = 2000
    API_LATENCY_CRITICAL_MS = 5000
    ERROR_RATE_WARNING = 0.01  # 1%
    ERROR_RATE_CRITICAL = 0.05  # 5%

    # Business metric thresholds
    TRAFFIC_DROP_WARNING = 0.3   # Below 30% of average
    TRAFFIC_DROP_CRITICAL = 0.1  # Below 10% of average
    ZERO_SIGNUP_HOURS = 24       # Alert if no signups for 24 hours

    @staticmethod
    async def run_health_checks() -> Dict[str, Any]:
        """
        Check all critical systems.

        Checks:
        - API response times (via health service)
        - Database connectivity
        - External service health (OpenAI, Anthropic, Stripe, Resend)
        - Demo generation success rate
        - PDF generation success rate

        Returns:
            Dict with overall status and individual service statuses
        """
        logger.info("Running critical health checks...")

        results: List[HealthCheckResult] = []
        alerts: List[MonitoringAlert] = []

        try:
            # Use existing health check infrastructure
            health_data = await check_all_health(include_external=True, timeout=30.0)

            overall_status = MonitoringStatus.GREEN

            # Process each service
            for service_name, service_data in health_data.get("services", {}).items():
                status = service_data.get("status", "unknown")
                latency = service_data.get("latency_ms")
                message = service_data.get("message")

                # Map health status to monitoring status
                if status == "unhealthy":
                    svc_status = MonitoringStatus.RED
                    overall_status = MonitoringStatus.RED

                    # Generate alert
                    alert = MonitoringAlert(
                        alert_type=f"service_{service_name}",
                        severity="critical",
                        message=f"{service_name.upper()} is unhealthy: {message or 'No details'}",
                        details=service_data
                    )
                    if _should_send_alert(f"service_{service_name}", "critical"):
                        alerts.append(alert)

                elif status == "degraded":
                    svc_status = MonitoringStatus.YELLOW
                    if overall_status != MonitoringStatus.RED:
                        overall_status = MonitoringStatus.YELLOW

                    # Generate warning alert
                    alert = MonitoringAlert(
                        alert_type=f"service_{service_name}",
                        severity="warning",
                        message=f"{service_name.upper()} is degraded: {message or 'No details'}",
                        details=service_data
                    )
                    if _should_send_alert(f"service_{service_name}", "warning"):
                        alerts.append(alert)
                else:
                    svc_status = MonitoringStatus.GREEN

                # Check latency thresholds
                if latency:
                    if latency > MonitoringAgentService.API_LATENCY_CRITICAL_MS:
                        alert = MonitoringAlert(
                            alert_type=f"latency_{service_name}",
                            severity="critical",
                            message=f"{service_name.upper()} latency critical: {latency:.0f}ms",
                            details={"latency_ms": latency, "threshold": MonitoringAgentService.API_LATENCY_CRITICAL_MS}
                        )
                        if _should_send_alert(f"latency_{service_name}", "critical"):
                            alerts.append(alert)
                        overall_status = MonitoringStatus.RED

                    elif latency > MonitoringAgentService.API_LATENCY_WARNING_MS:
                        alert = MonitoringAlert(
                            alert_type=f"latency_{service_name}",
                            severity="warning",
                            message=f"{service_name.upper()} latency elevated: {latency:.0f}ms",
                            details={"latency_ms": latency, "threshold": MonitoringAgentService.API_LATENCY_WARNING_MS}
                        )
                        if _should_send_alert(f"latency_{service_name}", "warning"):
                            alerts.append(alert)
                        if overall_status == MonitoringStatus.GREEN:
                            overall_status = MonitoringStatus.YELLOW

                results.append(HealthCheckResult(
                    name=service_name,
                    status=svc_status,
                    latency_ms=latency,
                    message=message
                ))

            # Check circuit breaker states
            for cb_name, cb_data in health_data.get("circuit_breakers", {}).items():
                if cb_data.get("state") == "open":
                    alert = MonitoringAlert(
                        alert_type=f"circuit_breaker_{cb_name}",
                        severity="warning",
                        message=f"Circuit breaker OPEN for {cb_name}",
                        details=cb_data
                    )
                    if _should_send_alert(f"circuit_breaker_{cb_name}", "warning"):
                        alerts.append(alert)
                    if overall_status == MonitoringStatus.GREEN:
                        overall_status = MonitoringStatus.YELLOW

            # Send critical alerts immediately
            if alerts:
                critical_alerts = [a for a in alerts if a.severity == "critical"]
                if critical_alerts:
                    await MonitoringAgentService._send_immediate_alert(critical_alerts)

            logger.info(f"Health check complete: {overall_status.value}, {len(alerts)} alerts")

            return {
                "status": overall_status.value,
                "timestamp": datetime.utcnow().isoformat(),
                "services": [r.__dict__ for r in results],
                "alerts": [a.to_dict() for a in alerts],
                "raw_health": health_data
            }

        except Exception as e:
            logger.error(f"Error in health checks: {e}")
            return {
                "status": MonitoringStatus.RED.value,
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "services": [],
                "alerts": []
            }

    @staticmethod
    async def check_business_metrics(db: AsyncSession) -> Dict[str, Any]:
        """
        Check business health metrics.

        Checks:
        - Traffic anomalies (3x spike or 50% drop)
        - Signup velocity
        - Demo-to-signup conversion
        - Payment failures

        Returns:
            Dict with metrics and any alerts
        """
        from .marketing_analytics import MarketingAnalyticsService
        from .traffic_spike_alerts import TrafficSpikeAlertService

        logger.info("Running business metrics check...")

        alerts: List[MonitoringAlert] = []

        try:
            # Get current metrics
            today_metrics = await MarketingAnalyticsService.get_daily_metrics(
                db, datetime.utcnow()
            )

            # Get 7-day averages
            week_metrics = await MarketingAnalyticsService.get_metrics_range(db, 7)

            # Calculate averages
            avg_signups = sum(m.signups for m in week_metrics) / len(week_metrics) if week_metrics else 0
            avg_quotes = sum(m.quotes_generated for m in week_metrics) / len(week_metrics) if week_metrics else 0

            # Check for significant drops
            if avg_signups > 0 and today_metrics.signups > 0:
                ratio = today_metrics.signups / avg_signups

                if ratio <= MonitoringAgentService.TRAFFIC_DROP_CRITICAL:
                    alert = MonitoringAlert(
                        alert_type="signup_drop",
                        severity="critical",
                        message=f"CRITICAL: Signups at {ratio:.0%} of average ({today_metrics.signups} vs {avg_signups:.1f}/day)",
                        details={
                            "current": today_metrics.signups,
                            "average": avg_signups,
                            "ratio": ratio
                        }
                    )
                    if _should_send_alert("signup_drop", "critical"):
                        alerts.append(alert)

                elif ratio <= MonitoringAgentService.TRAFFIC_DROP_WARNING:
                    alert = MonitoringAlert(
                        alert_type="signup_drop",
                        severity="warning",
                        message=f"Signups down: {ratio:.0%} of average ({today_metrics.signups} vs {avg_signups:.1f}/day)",
                        details={
                            "current": today_metrics.signups,
                            "average": avg_signups,
                            "ratio": ratio
                        }
                    )
                    if _should_send_alert("signup_drop", "warning"):
                        alerts.append(alert)

            # Check for zero signups (potential issue)
            if avg_signups > 0.5 and today_metrics.signups == 0:
                # Only alert if it's been more than 12 hours into the day
                hours_into_day = datetime.utcnow().hour
                if hours_into_day >= 12:
                    alert = MonitoringAlert(
                        alert_type="zero_signups",
                        severity="warning",
                        message=f"No signups today (average: {avg_signups:.1f}/day). Check ads and landing page.",
                        details={
                            "hours_into_day": hours_into_day,
                            "average": avg_signups
                        }
                    )
                    if _should_send_alert("zero_signups", "warning"):
                        alerts.append(alert)

            # Traffic spike detection (delegate to existing service)
            spike_alerts = await TrafficSpikeAlertService.detect_spikes(db)
            for spike in spike_alerts:
                alert = MonitoringAlert(
                    alert_type=f"spike_{spike.alert_type}",
                    severity=spike.severity,
                    message=spike.message,
                    details={
                        "current": spike.current_value,
                        "average": spike.average_value,
                        "multiplier": spike.multiplier
                    }
                )
                if _should_send_alert(f"spike_{spike.alert_type}", spike.severity):
                    alerts.append(alert)

            # Traffic drop detection
            drop_alerts = await TrafficSpikeAlertService.detect_traffic_drops(db)
            for drop in drop_alerts:
                alert = MonitoringAlert(
                    alert_type=f"drop_{drop.alert_type}",
                    severity=drop.severity,
                    message=drop.message,
                    details={
                        "current": drop.current_value,
                        "average": drop.average_value,
                        "ratio": drop.multiplier
                    }
                )
                if _should_send_alert(f"drop_{drop.alert_type}", drop.severity):
                    alerts.append(alert)

            # Send any critical or multiple warning alerts
            critical_alerts = [a for a in alerts if a.severity == "critical"]
            warning_alerts = [a for a in alerts if a.severity == "warning"]

            if critical_alerts:
                await MonitoringAgentService._send_immediate_alert(critical_alerts)
            elif len(warning_alerts) >= 2:
                # Multiple warnings = worth an email
                await MonitoringAgentService._send_immediate_alert(warning_alerts)

            logger.info(f"Business metrics check complete: {len(alerts)} alerts")

            return {
                "timestamp": datetime.utcnow().isoformat(),
                "metrics": {
                    "signups_today": today_metrics.signups,
                    "quotes_today": today_metrics.quotes_generated,
                    "avg_signups_7d": avg_signups,
                    "avg_quotes_7d": avg_quotes
                },
                "alerts": [a.to_dict() for a in alerts]
            }

        except Exception as e:
            logger.error(f"Error in business metrics check: {e}")
            return {
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e),
                "metrics": {},
                "alerts": []
            }

    @staticmethod
    async def generate_daily_summary(db: AsyncSession) -> str:
        """
        Generate founder briefing email.

        Includes:
        - System health status (GREEN/YELLOW/RED)
        - Key metrics vs. 7-day average
        - Anomalies detected in last 24 hours
        - Recommended actions with priority

        Returns:
            HTML content for the email
        """
        from .marketing_analytics import MarketingAnalyticsService

        logger.info("Generating daily summary...")

        try:
            # Get health status
            health_data = await MonitoringAgentService.run_health_checks()
            overall_health = health_data.get("status", "unknown")

            # Get business metrics
            yesterday = await MarketingAnalyticsService.get_daily_metrics(db)
            totals = await MarketingAnalyticsService.get_total_counts(db)
            week_metrics = await MarketingAnalyticsService.get_metrics_range(db, 7)

            # Calculate trends
            avg_signups = sum(m.signups for m in week_metrics) / len(week_metrics) if week_metrics else 0
            avg_quotes = sum(m.quotes_generated for m in week_metrics) / len(week_metrics) if week_metrics else 0

            # Build trend indicators
            def trend_indicator(current: int, average: float) -> tuple:
                """Returns (emoji, text description)."""
                if average == 0:
                    return ("", "N/A")
                pct = ((current - average) / average) * 100
                if pct > 20:
                    return ("green", f"+{pct:.0f}%")
                elif pct < -20:
                    return ("red", f"{pct:.0f}%")
                else:
                    return ("yellow", f"{pct:+.0f}%")

            signup_trend = trend_indicator(yesterday.signups, avg_signups)
            quote_trend = trend_indicator(yesterday.quotes_generated, avg_quotes)

            # Health status styling
            health_colors = {
                "green": "#22c55e",
                "yellow": "#eab308",
                "red": "#ef4444"
            }
            health_color = health_colors.get(overall_health, "#a0a0a0")
            health_emoji = {"green": "OK", "yellow": "DEGRADED", "red": "CRITICAL"}.get(overall_health, "UNKNOWN")

            # Service status summary
            services_html = ""
            for service in health_data.get("services", []):
                svc_color = health_colors.get(service.get("status", ""), "#a0a0a0")
                svc_name = service.get("name", "unknown").upper()
                svc_latency = service.get("latency_ms")
                latency_text = f" ({svc_latency:.0f}ms)" if svc_latency else ""
                services_html += f'<span style="color: {svc_color};">{svc_name}{latency_text}</span> | '

            services_html = services_html.rstrip(" | ")

            # Recent alerts summary
            alerts_html = ""
            all_alerts = health_data.get("alerts", [])
            if all_alerts:
                alerts_html = "<h3 style='color: #ffffff; margin-top: 24px;'>Recent Alerts</h3><ul style='color: #e0e0e0;'>"
                for alert in all_alerts[:5]:  # Max 5 alerts
                    severity_color = {"critical": "#ef4444", "warning": "#eab308", "info": "#3b82f6"}.get(alert.get("severity", ""), "#a0a0a0")
                    alerts_html += f'<li style="margin-bottom: 8px;"><span style="color: {severity_color};">[{alert.get("severity", "").upper()}]</span> {alert.get("message", "")}</li>'
                alerts_html += "</ul>"
            else:
                alerts_html = '<p style="color: #22c55e;">No alerts in the last 24 hours.</p>'

            # Recommendations
            recommendations = []
            if overall_health == "red":
                recommendations.append("Check Railway logs for errors: `railway logs -n 200`")
            if yesterday.signups == 0 and avg_signups > 0:
                recommendations.append("Check Google Ads - no signups yesterday")
            if signup_trend[0] == "red":
                recommendations.append(f"Signups down {signup_trend[1]} - review landing page and ads")

            recs_html = ""
            if recommendations:
                recs_html = "<h3 style='color: #ffffff; margin-top: 24px;'>Recommended Actions</h3><ol style='color: #e0e0e0;'>"
                for rec in recommendations:
                    recs_html += f'<li style="margin-bottom: 8px;">{rec}</li>'
                recs_html += "</ol>"

            # Build the email
            date_str = datetime.utcnow().strftime("%B %d, %Y")

            html = f"""
            <h1>Daily Briefing</h1>
            <p style="color: #a0a0a0; font-size: 14px;">{date_str}</p>

            <div style="background-color: #1a1a1a; border-left: 4px solid {health_color}; border-radius: 8px; padding: 20px; margin: 24px 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #a0a0a0; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">System Status</div>
                        <div style="color: {health_color}; font-size: 24px; font-weight: 600;">{health_emoji}</div>
                    </div>
                </div>
                <div style="margin-top: 16px; color: #a0a0a0; font-size: 13px;">
                    {services_html}
                </div>
            </div>

            <div class="stats-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin: 24px 0;">
                <div class="stat-box" style="background-color: #1a1a1a; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 20px;">
                    <div class="stat-value" style="font-size: 28px; font-weight: 600; color: #ffffff;">{yesterday.signups}</div>
                    <div class="stat-label" style="font-size: 13px; color: #a0a0a0;">Signups Yesterday</div>
                    <div style="color: {health_colors.get(signup_trend[0], '#a0a0a0')}; font-size: 12px; margin-top: 8px;">{signup_trend[1]} vs avg</div>
                </div>
                <div class="stat-box" style="background-color: #1a1a1a; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 20px;">
                    <div class="stat-value" style="font-size: 28px; font-weight: 600; color: #ffffff;">{yesterday.quotes_generated}</div>
                    <div class="stat-label" style="font-size: 13px; color: #a0a0a0;">Quotes Generated</div>
                    <div style="color: {health_colors.get(quote_trend[0], '#a0a0a0')}; font-size: 12px; margin-top: 8px;">{quote_trend[1]} vs avg</div>
                </div>
            </div>

            <div style="background-color: #1a1a1a; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 20px; margin: 24px 0;">
                <div style="color: #ffffff; font-size: 16px; font-weight: 600; margin-bottom: 16px;">All-Time Totals</div>
                <div style="color: #e0e0e0; font-size: 15px; line-height: 1.8;">
                    <strong>Total Signups:</strong> {totals['total_signups']}<br>
                    <strong>Total Quotes:</strong> {totals['total_quotes']}<br>
                    <strong>Paying Users:</strong> {totals['paying_users']}
                </div>
            </div>

            {alerts_html}

            {recs_html}

            <p class="muted" style="margin-top: 32px; font-size: 12px; color: #a0a0a0;">
                Generated by DISC-140 Monitoring Agent at {datetime.utcnow().strftime("%H:%M UTC")}.<br>
                To adjust settings, edit MONITORING_AGENT_ENABLED in Railway.
            </p>
            """

            logger.info("Daily summary generated successfully")
            return html

        except Exception as e:
            logger.error(f"Error generating daily summary: {e}")
            return f"""
            <h1>Daily Briefing - Error</h1>
            <p style="color: #ef4444;">Failed to generate daily summary: {str(e)}</p>
            <p style="color: #a0a0a0;">Check Railway logs for details.</p>
            """

    @staticmethod
    async def send_daily_summary(db: AsyncSession) -> bool:
        """
        Generate and send the daily summary email to founder.

        Returns:
            True if sent successfully
        """
        from .email import EmailService

        logger.info("Sending daily summary email...")

        try:
            html_content = await MonitoringAgentService.generate_daily_summary(db)

            date_str = datetime.utcnow().strftime("%b %d")
            subject = f"Quoted Daily Briefing - {date_str}"

            await EmailService.send_email(
                to_email=settings.founder_email,
                subject=subject,
                body=html_content
            )

            logger.info(f"Daily summary sent to {settings.founder_email}")
            return True

        except Exception as e:
            logger.error(f"Failed to send daily summary: {e}")
            return False

    @staticmethod
    async def _send_immediate_alert(alerts: List[MonitoringAlert]) -> bool:
        """
        Send immediate alert email to founder.

        Args:
            alerts: List of alerts to include

        Returns:
            True if sent successfully
        """
        from .email import EmailService

        if not alerts:
            return True

        try:
            # Build alert HTML
            max_severity = max(a.severity for a in alerts)
            severity_emoji = {"critical": "!!!", "warning": "!!", "info": "!"}.get(max_severity, "")
            severity_color = {"critical": "#ef4444", "warning": "#eab308", "info": "#3b82f6"}.get(max_severity, "#a0a0a0")

            alerts_html = ""
            for alert in alerts:
                alert_color = {"critical": "#ef4444", "warning": "#eab308", "info": "#3b82f6"}.get(alert.severity, "#a0a0a0")
                alerts_html += f"""
                <div style="background-color: #1a1a1a; border-left: 4px solid {alert_color}; border-radius: 8px; padding: 20px; margin: 16px 0;">
                    <div style="color: {alert_color}; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;">
                        {alert.severity.upper()} - {alert.alert_type}
                    </div>
                    <div style="color: #ffffff; font-size: 16px;">
                        {alert.message}
                    </div>
                </div>
                """

            html_content = f"""
            <h1 style="color: {severity_color};">Monitoring Alert{severity_emoji}</h1>
            <p style="color: #a0a0a0; font-size: 14px;">{datetime.utcnow().strftime("%B %d, %Y at %H:%M UTC")}</p>

            {alerts_html}

            <p class="muted" style="margin-top: 32px; font-size: 12px; color: #a0a0a0;">
                Generated by DISC-140 Monitoring Agent.<br>
                Alert deduplication: Same alerts won't repeat for {int(ALERT_DEDUP_WINDOW.total_seconds() / 60)} minutes.
            </p>
            """

            alert_types = ", ".join(set(a.alert_type for a in alerts))
            subject = f"Monitoring Alert{severity_emoji}: {alert_types}"

            await EmailService.send_email(
                to_email=settings.founder_email,
                subject=subject,
                body=html_content
            )

            logger.info(f"Immediate alert sent: {len(alerts)} alerts")
            return True

        except Exception as e:
            logger.error(f"Failed to send immediate alert: {e}")
            return False


# =========================================================================
# Scheduler Entry Points
# =========================================================================

async def run_critical_health_checks():
    """
    Scheduled job function for critical health checks.
    Runs every 15 minutes via APScheduler.
    """
    if not getattr(settings, 'monitoring_agent_enabled', True):
        logger.debug("Monitoring agent disabled")
        return

    _cleanup_dedup_cache()

    try:
        await MonitoringAgentService.run_health_checks()
    except Exception as e:
        logger.error(f"Error in run_critical_health_checks: {e}")


async def run_business_metrics_check():
    """
    Scheduled job function for business metrics check.
    Runs every hour via APScheduler.
    """
    from .database import async_session_factory

    if not getattr(settings, 'monitoring_agent_enabled', True):
        logger.debug("Monitoring agent disabled")
        return

    try:
        async with async_session_factory() as db:
            await MonitoringAgentService.check_business_metrics(db)
    except Exception as e:
        logger.error(f"Error in run_business_metrics_check: {e}")


async def run_daily_monitoring_summary():
    """
    Scheduled job function for daily summary.
    Runs daily at 8:15 AM UTC via APScheduler.
    """
    from .database import async_session_factory

    if not getattr(settings, 'monitoring_agent_enabled', True):
        logger.debug("Monitoring agent disabled")
        return

    try:
        async with async_session_factory() as db:
            await MonitoringAgentService.send_daily_summary(db)
    except Exception as e:
        logger.error(f"Error in run_daily_monitoring_summary: {e}")
